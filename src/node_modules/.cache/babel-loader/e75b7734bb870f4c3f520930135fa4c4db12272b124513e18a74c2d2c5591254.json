{"ast":null,"code":"import { io } from 'socket.io-client';\nimport store from '../store';\nimport { setStatus, setSocket, setError } from '../store/slices/websocketSlice';\nimport { addMessage } from '../store/slices/chatSlice';\nimport { updateComponentStatus } from '../store/slices/componentsSlice';\nlet socket = null;\nexport const connectWebSocket = () => {\n  const {\n    dispatch\n  } = store;\n\n  // If already connected, return the socket\n  if (socket) {\n    return socket;\n  }\n\n  // Update connection status\n  dispatch(setStatus('connecting'));\n\n  // Connect to WebSocket server\n  socket = io({\n    path: '/ws',\n    reconnectionAttempts: 5,\n    reconnectionDelay: 1000,\n    reconnectionDelayMax: 5000\n  });\n\n  // Save socket in store\n  dispatch(setSocket(socket));\n\n  // Handle connection events\n  socket.on('connect', () => {\n    dispatch(setStatus('connected'));\n  });\n  socket.on('disconnect', () => {\n    dispatch(setStatus('disconnected'));\n  });\n  socket.on('connect_error', error => {\n    dispatch(setError(error.message));\n    dispatch(setStatus('disconnected'));\n  });\n\n  // Handle server messages\n  socket.on('component_update', data => {\n    dispatch(updateComponentStatus({\n      componentId: data.id,\n      status: data.status\n    }));\n  });\n  socket.on('message', data => {\n    dispatch(addMessage(data));\n  });\n  return socket;\n};\nexport const disconnectWebSocket = () => {\n  if (socket) {\n    socket.disconnect();\n    socket = null;\n    store.dispatch(setStatus('disconnected'));\n    store.dispatch(setSocket(null));\n  }\n};\nexport const sendMessage = message => {\n  if (socket && socket.connected) {\n    socket.emit('send_message', message);\n    return true;\n  }\n  return false;\n};\nexport const sendCommand = (componentId, command, data) => {\n  if (socket && socket.connected) {\n    const requestId = Date.now().toString();\n    socket.emit('send_command', {\n      type: 'send_command',\n      component_id: componentId,\n      command,\n      data,\n      request_id: requestId\n    });\n    return requestId;\n  }\n  return null;\n};\nexport const checkDeadlocks = () => {\n  if (socket && socket.connected) {\n    const requestId = Date.now().toString();\n    socket.emit('check_deadlocks', {\n      type: 'check_deadlocks',\n      request_id: requestId\n    });\n    return requestId;\n  }\n  return null;\n};\nexport default {\n  connectWebSocket,\n  disconnectWebSocket,\n  sendMessage,\n  sendCommand,\n  checkDeadlocks\n};","map":{"version":3,"names":["io","store","setStatus","setSocket","setError","addMessage","updateComponentStatus","socket","connectWebSocket","dispatch","path","reconnectionAttempts","reconnectionDelay","reconnectionDelayMax","on","error","message","data","componentId","id","status","disconnectWebSocket","disconnect","sendMessage","connected","emit","sendCommand","command","requestId","Date","now","toString","type","component_id","request_id","checkDeadlocks"],"sources":["/Users/cskoons/projects/github/Tekton/Hephaestus/src/services/websocketService.js"],"sourcesContent":["import { io } from 'socket.io-client';\nimport store from '../store';\nimport { setStatus, setSocket, setError } from '../store/slices/websocketSlice';\nimport { addMessage } from '../store/slices/chatSlice';\nimport { updateComponentStatus } from '../store/slices/componentsSlice';\n\nlet socket = null;\n\nexport const connectWebSocket = () => {\n  const { dispatch } = store;\n\n  // If already connected, return the socket\n  if (socket) {\n    return socket;\n  }\n\n  // Update connection status\n  dispatch(setStatus('connecting'));\n\n  // Connect to WebSocket server\n  socket = io({\n    path: '/ws',\n    reconnectionAttempts: 5,\n    reconnectionDelay: 1000,\n    reconnectionDelayMax: 5000,\n  });\n\n  // Save socket in store\n  dispatch(setSocket(socket));\n\n  // Handle connection events\n  socket.on('connect', () => {\n    dispatch(setStatus('connected'));\n  });\n\n  socket.on('disconnect', () => {\n    dispatch(setStatus('disconnected'));\n  });\n\n  socket.on('connect_error', (error) => {\n    dispatch(setError(error.message));\n    dispatch(setStatus('disconnected'));\n  });\n\n  // Handle server messages\n  socket.on('component_update', (data) => {\n    dispatch(updateComponentStatus({\n      componentId: data.id,\n      status: data.status\n    }));\n  });\n\n  socket.on('message', (data) => {\n    dispatch(addMessage(data));\n  });\n\n  return socket;\n};\n\nexport const disconnectWebSocket = () => {\n  if (socket) {\n    socket.disconnect();\n    socket = null;\n    store.dispatch(setStatus('disconnected'));\n    store.dispatch(setSocket(null));\n  }\n};\n\nexport const sendMessage = (message) => {\n  if (socket && socket.connected) {\n    socket.emit('send_message', message);\n    return true;\n  }\n  return false;\n};\n\nexport const sendCommand = (componentId, command, data) => {\n  if (socket && socket.connected) {\n    const requestId = Date.now().toString();\n    socket.emit('send_command', {\n      type: 'send_command',\n      component_id: componentId,\n      command,\n      data,\n      request_id: requestId,\n    });\n    return requestId;\n  }\n  return null;\n};\n\nexport const checkDeadlocks = () => {\n  if (socket && socket.connected) {\n    const requestId = Date.now().toString();\n    socket.emit('check_deadlocks', {\n      type: 'check_deadlocks',\n      request_id: requestId,\n    });\n    return requestId;\n  }\n  return null;\n};\n\nexport default {\n  connectWebSocket,\n  disconnectWebSocket,\n  sendMessage,\n  sendCommand,\n  checkDeadlocks,\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}